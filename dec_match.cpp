#include <iostream>
#include <vector>
#include <map>
#include <string>
#include <fstream>
#include <random>
#include <chrono>
#include <initializer_list>
#include <opencv2/opencv.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <typeinfo>
#include <iterator>
#include "cmath"


#include "header.h"
#include <matrix.h>
#include <munkres.h>
#include "utils.h"
#include "dection.h"
#include "mybox.h"
#include "getline.h"
#include "distance.h"
#include "judge.h"
#include <tracker.h>
#include <kalman_filter.h>
#include "darknet.h"
#include "dec_match.h"
#include "defthreshold.h"

#include <improcess.h>

#include "mulplayer.h"
#include <QApplication>
#include <QSqlQuery>
#include <QDateTime>
#include "ui_mulplayer.h"
#include "connection.h"

//#define self 1//display or not  class



#define judge 1//draw bbox

using namespace std;

/*int main11(MulPlayer*p){
    //std::string path="/home/ps/zk/darknet-master-1";
    //cv::VideoCapture capture(path+"/car-bicycle.mp4");//读取视频，请自行修改相应路径777777777777777777777777
    cv::VideoCapture capture(1);
    cv::VideoCapture capture1(2);
    int frame_count=1;
    cv::Mat frame;
    cv::Mat frame2;
    while(1){


        if (!capture.read(frame)){//read one frame photo
            printf("fail to read.\n");
            return 0;
        }
        ++frame_count;
        cv::imshow("Original", frame);
        cv::imshow("Original", frame2);
        p->video_opencv(frame,1);
        p->video_opencv(frame2,2);
        cv::waitKey(1);

    }
    return 0;

}*/


/*
int main11(MulPlayer*p)
{

    cv::Mat frame;
    cv::Mat frame2;

    cv::VideoCapture cap1(0);
    cv::VideoCapture cap2(1);

    bool stop(false);

    cv::namedWindow("cam1", CV_WINDOW_AUTOSIZE);
    cv::namedWindow("cam2", CV_WINDOW_AUTOSIZE);


    if (cap1.isOpened() && cap2.isOpened())
    {
        cout << "*** ***" << endl;
        cout << "摄像头已启动！" << endl;
    }
    else
    {
        cout << "*** ***" << endl;
        cout << "警告：请检查摄像头是否安装好!" << endl;
        cout << "程序结束！" << endl << "*** ***" << endl;
        return -1;
    }


    cap1.set(CV_CAP_PROP_FOCUS, 0);
    cap2.set(CV_CAP_PROP_FOCUS, 0);


    while (!stop)
    {
        if (cap1.read(frame) && cap2.read(frame2))
        {
            imshow("cam1", frame);
            //imshow("cam2", frame2);

            p->video_opencv(frame);
            //p->video_opencv(frame2,2);

            imwrite("frame1.bmp", frame);
            //imwrite("frame2.bmp", frame2);

            //彩色帧转灰度
            cvtColor(frame, frame, CV_RGB2GRAY);
            //cvtColor(frame2, frame2, CV_RGB2GRAY);


            if (cv::waitKey(1) == 27)//按ESC键
            {
                stop = true;
                cout << "程序结束！" << endl;
                cout << "*** ***" << endl;
            }
        }
    }
    return 0;
}*/

std::string  dec_and_match(std::string video_path, MulPlayer*p,int num = 0)
{

        //main11(p);
        //return 0;

        std::string name=video_path.substr(video_path.find_last_of("/")+1,video_path.find_last_of(".")-video_path.find_last_of("/")-1);
        //example name=01
        std::string folder=video_path.substr(0,video_path.find_last_of("/")+1);


        //end with /
        bool enable_display_flag=true;
        std::vector<cv::Scalar> colors;
        constexpr int num_of_colors = 32;
        std::random_device rd;  //Will be used to obtain a seed for the random number engine
        std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
        constexpr int max_random_value = 20;
        std::uniform_int_distribution<> dis(0, max_random_value);
        constexpr int factor = 255 / max_random_value;
        for (int n = 0; n < num_of_colors; ++n) {
                        //Use dis to transform the random unsigned int generated by gen into an int in [0, 7]
                        colors.emplace_back(cv::Scalar(dis(gen) * factor, dis(gen) * factor, dis(gen) * factor));
                    }
        std::string darknet_path="/home/ps/zk/darknet-master-1";
        std::string cfgfile =darknet_path+"/cfg/yolov3.cfg";//读取模型文件，请自行修改相应路径
        std::string weightfile =darknet_path+"/yolov3.weights";

        float thresh=0.5;//参数设置
        float nms=0.35;
        int classes=8;


        network *net=load_network((char*)cfgfile.c_str(),(char*)weightfile.c_str(),0);//加载网络模型
        //network is a struct

        set_batch_network(net, 1);//no return

        cv::VideoCapture capture(video_path);//读取视频，请自行修改相应路径777777777777777777777777
        //cv::VideoCapture capture(0);


        cv::namedWindow("cam1", CV_WINDOW_AUTOSIZE);

        p->printmsg("读取视频成功. . .");
        double fps = capture.get(cv::CAP_PROP_FPS);

        cv::Size size((int)capture.get(cv::CAP_PROP_FRAME_WIDTH), (int)capture.get(cv::CAP_PROP_FRAME_HEIGHT));

        cv::VideoWriter writer_match;
        writer_match.open("match.mp4", CV_FOURCC('M', 'J', 'P', 'G'), fps, size, true);
        cv::VideoWriter writer_dec;
        writer_dec.open("dec.mp4", CV_FOURCC('M', 'J', 'P', 'G'), fps, size, true);




        cv::Mat frame;

        cv::Mat rgbImg;


        int missaccident_count=0;//总计消失对象的事故个数
        int nomissaccident_count=0;//总计未消失对象的事故个数
        int like_count=0;
        int vfilterfimss_count=0;
        int addvfilterfmiss_count=0;
        int fmissaccident_count=0;
        int like1_count=0;
        int stayaccident_count=0;
        int total_vs_count=0;

        std::vector<mybox> bbox_per_frame;
        std::vector<std::vector<mybox>> bbox1;
        std::vector<missingbox>miss_to_accidentboxes;//确认为事故的ID（有消失）
        std::vector<mybox>highaboxes;//高加速度的对象
        std::vector<mybox>nomiss_to_accidentboxes;//确认为事故的ID（无消失）
        std::vector<missingbox>like_accidentboxes;//对于消失的ID，通过前后两帧对比找出的疑似事故对象
        std::vector<mybox>like_accidentboxes1;
        std::vector<missingbox> miss_boxes;
        std::vector<mybox> neighbourboxes;
        std::vector<mybox> neighbourboxes1;
        std::vector<missingbox>fmiss_to_accidentboxes;//经过neighbourcheck后的miss_to_accidentboxes
        std::vector<missingbox> countedlike_boxes;//存放已经统计过的疑似对象
        std::vector<missingbox> vfilter_fmiss;//速度滤波后的fmiss
        std::vector<missingbox> vfilter_for_stay;//速度不小,后续stay筛选
        std::vector<missingbox> stay_to_accidentboxes;//crashone碰撞后静止检测(miss已消失)
        std::vector<mybox> stay_to_accidentboxes1;
        std::vector<mybox> high_accelerationboxes;
        std::vector<missingbox> total_vfilter_stay;//静止检测和速度滤波后的输出事故对象
        std::vector<motionparasbox> motionparasboxes;

        bool flag_ID_missing=true;
        bool onlyone_mtoacci=false;
        float mindistance=0;
        float mindistance1=0;



        std::vector<string> classNamesVec;

        std::ifstream classNamesFile(darknet_path+"/data/coco.names");//标签文件coco有80类


        if (classNamesFile.is_open()){
            string className = "";
            while (getline(classNamesFile, className))
                classNamesVec.push_back(className);
        }



        //std::string output_v=darknet_path+"/v.txt";//export all 'v' and 'a'
        std::string output_v="v_1.txt";

        std::ofstream foutput_v(output_v);

        std::string output_path = folder+name+"match.txt";//有输出trk after match


        std::ofstream output_file(output_path);



               // TODO: check if output folder exist
               if (output_file.is_open()) {
                   std::cout << "Result will be exported to " << output_path << std::endl;
               } else {
                   std::cerr << "Unable to open output file" << std::endl;
                  // return -1;
               }

        int current_ID = 0;

        bool stop=false;//
        int frame_index=1;

        std::map<int, Tracker> tracks;

     //   while(frame_index<capture.get(cv::CAP_PROP_FRAME_COUNT)){
        std::cout<<capture.get(cv::CAP_PROP_FRAME_COUNT);

        while(frame_index<capture.get(cv::CAP_PROP_FRAME_COUNT)-5){//9999999999999999999999999999999999999999999999999
        //while(1){
            p->printmsg("正在处理第"+std::to_string(frame_index)+"帧视频. . .");
            constexpr float dt = 0.03333333333333f;//predit of kalman

                        for (auto &track : tracks) {
                            track.second.Predict(dt);
                        }

            if (!capture.read(frame)){//read one frame photo
                printf("fail to read.\n");
               // return 0;
                std::cout<<"if frame"<<std::endl;
                return output_path;
               // return "\0";
            }



            cv::Mat img_tracking = frame.clone();

            cvtColor(frame, rgbImg, cv::COLOR_BGR2RGB);

            float* srcImg;
            size_t srcSize=rgbImg.rows*rgbImg.cols*3*sizeof(float);

            srcImg=(float*)malloc(srcSize);
            imgConvert(rgbImg,srcImg);//将图像转为yolo形式

            float* resizeImg;

            size_t resizeSize=net->w*net->h*3*sizeof(float);

            resizeImg=(float*)malloc(resizeSize);

            imgResize(srcImg,resizeImg,frame.cols,frame.rows,net->w,net->h);//缩放图像

            network_predict(net,resizeImg);//网络推理

            int nboxes=0;
            int nboxes_2=0;
            int nboxes_3=0;
            int nboxes_4=0;
            detection *dets=get_network_boxes(net,rgbImg.cols,rgbImg.rows,thresh,0.5,0,1,&nboxes);//a struct pull

            if(nms){//nms is yuzhi??????????
                do_nms_obj(dets,nboxes,classes,nms);//no return
            }

            vector<Rect_with_class>one_frame_dec;
            Rect_with_class one_dec;

            for (int i = 0; i < nboxes; i++){//nboxes represent the number of dection
                bool flag=0;
                int className;
                for(int j=1;j<=classes;j++){
                    if(dets[i].prob[j-1]>thresh){
                        if(!flag){
                            flag=1;
                            className=j;

                        }
                    }
                }//
                if(flag){//read all bbox in the same frame
                    int left = (dets[i].bbox.x - dets[i].bbox.w / 2.)*frame.cols;
                    int right = (dets[i].bbox.x + dets[i].bbox.w / 2.)*frame.cols;
                    int top = (dets[i].bbox.y - dets[i].bbox.h / 2.)*frame.rows;
                    int bot = (dets[i].bbox.y + dets[i].bbox.h / 2.)*frame.rows;

                    if (left < 0)
                        left = 0;
                    if (right > frame.cols - 1)
                        right = frame.cols - 1;
                    if (top < 0)
                        top = 0;
                    if (bot > frame.rows - 1)
                        bot = frame.rows - 1;

                    one_dec.init(left, top, fabs(left - right), fabs(top - bot),className);//is it right????????????
                    one_frame_dec.push_back(one_dec);
                }
            }
            //for end one frame end,begin match

            free_detections(dets, nboxes);

           for (auto &trk : tracks) {//draw prediction box and to txt

                if (judge||(trk.second.hit_streak_ >= kMinHits || frame_index < kMinHits)) {
                    const auto &bbox = trk.second.GetStateAsBbox();
                    cv::Rect myRect_to_cv(bbox.block.x,bbox.block.y,bbox.block.width,bbox.block.height);
                    std::string display_str=std::to_string(frame_index);
                    display_str+=std::to_string(trk.first);
                    cv::putText(frame, display_str, cv::Point(bbox.block.tl().x, bbox.block.tl().y - 5), cv::FONT_HERSHEY_DUPLEX, 1, cv::Scalar(255, 255, 255), 1);
                    cv::rectangle(frame, myRect_to_cv, cv::Scalar(0, 255, 0), 3);
                }
            }


            std::map<int,Rect_with_class > matched;

            std::vector<Rect_with_class> unmatched_det;

            AssociateDetectionsToTrackers(one_frame_dec, tracks, matched, unmatched_det,0.45);
                         //相应的输入变量类型 std::vector<cv::Rect>& detection,std::map<int, Tracker>& tracks,std::map<int, cv::Rect>& matched,std::vector<cv::Rect>& unmatched_det,
                        /*** Update tracks with associated bbox ***/
                        for (const auto &match : matched) {
                            const auto &ID = match.first;
                            tracks[ID].Update(match.second);

                            const auto &bbox = tracks[ID].GetStateAsBbox();//draw trk
                            cv::Rect myRect_to_cv(bbox.block.x,bbox.block.y,bbox.block.width,bbox.block.height);
                            //std::string display_str=std::to_string(ID)+" "+std::to_string((int)(CalculateIou(match.second,tracks[ID])*100))+" "+std::to_string(frame_index);
                            std::string display_str=std::to_string(ID)+" "+std::to_string(frame_index);
                            //cv::putText(img_tracking, display_str, cv::Point(bbox.block.tl().x, bbox.block.tl().y - 10),cv::FONT_HERSHEY_DUPLEX, 1, cv::Scalar(255, 255, 255), 1);
                          //  cv::rectangle(img_tracking, myRect_to_cv,cv::Scalar(255, 0, 0), 1);//blue

                            Rect_with_class decbbox = match.second;//draw dec
                            //cv::Rect decRect_to_cv(decbbox.block.x,decbbox.block.y,decbbox.block.width,decbbox.block.height);
                          // cv::rectangle(img_tracking, decRect_to_cv,cv::Scalar(0, 255, 0), 1);//green
                        }

                        /*** Create new tracks for unmatched detections ***/
                        for (const auto &det : unmatched_det) {
                            Tracker tracker;
                            tracker.Init(det);
                            // Create new track and generate new ID
                            tracks[current_ID++] = tracker;
                        }

                        /*** Delete lose tracked tracks ***/
                        for (auto it = tracks.begin(); it != tracks.end();) {
                            if (it->second.coast_cycles_ > kMaxCoastCycles) {
                                it = tracks.erase(it);
                            } else {
                                it++;
                            }
                        }

                        //output_file << frame_index<<",";
                        for (auto &trk : tracks) { //tracker to  txt
                            const auto &bbox = trk.second.GetStateAsBbox();

                            if (trk.second.hit_streak_ >= kMinHits || frame_index < kMinHits) {
                            // Print to terminal for debugging
                                std::cout << frame_index << "," << trk.first << "," << bbox.block.tl().x << "," << bbox.block.tl().y
                                          << "," << bbox.block.width << "," << bbox.block.height << ",1,-1,-1,-1"
                                          << " Hit Streak = " << trk.second.hit_streak_
                                          << " Coast Cycles = " << trk.second.coast_cycles_ << std::endl;

                                // Export to text file for metrics evaluation
                                //central point!
                                output_file << frame_index << "," << trk.first << "," <<"1,"<<trk.second.category<<","
                                             << bbox.block.tl().x+bbox.block.width*0.5<< "," << bbox.block.tl().y+bbox.block.height*0.5<< "," << bbox.block.width << "," << bbox.block.height<<","
                                             <<trk.second.GetMotionState()(4)<<","<<trk.second.GetMotionState()(5)<<","<<trk.second.GetMotionState()(0)<<","<<trk.second.GetMotionState()(1)<<endl;
                                /*output_file   << trk.first << "," <<"1,"<<trk.second.category<<","
                                             << bbox.block.tl().x << "," << bbox.block.tl().y<< "," << bbox.block.width << "," << bbox.block.height<<","
                                             <<trk.second.GetMotionState()(3)<<","<<trk.second.GetMotionState()(5)<<","<<trk.second.GetMotionState()(0)<<","<<trk.second.GetMotionState()(1);*/

                                double v = sqrt(trk.second.GetMotionState()(4)*trk.second.GetMotionState()(4) + trk.second.GetMotionState()(5)*trk.second.GetMotionState()(5));
                                double a = sqrt(trk.second.GetMotionState()(0)*trk.second.GetMotionState()(0) + trk.second.GetMotionState()(1)*trk.second.GetMotionState()(1));
                                double v_angle = atan2(trk.second.GetMotionState()(5), trk.second.GetMotionState()(4));
                                double a_angle = atan2(trk.second.GetMotionState()(1), trk.second.GetMotionState()(0));
                                foutput_v<<frame_index<<","<<trk.first<<","<<v<<","<<a<<","<<v_angle<<","<<a_angle<<endl;

                            }
                        }
                        //output_file<<endl;




                        if (enable_display_flag) {
                                        if (frame.empty()) {
                                            std::cerr << "Could not open or find the image!!!" << std::endl;
                                            //return -1;
                                        }

                                        for (const auto &det : one_frame_dec) {
                                            // Draw detected bounding boxes in red
                                            cv::Rect myRect_to_cv(det.block.x,det.block.y,det.block.width,det.block.height);
                                            std::string display_str=std::to_string(frame_index);
                                            cv::rectangle(frame, myRect_to_cv, cv::Scalar(0, 0, 255), 3);
                                        }

                                        for (auto &trk : tracks) {//draw box after matching

                                            if ((trk.second.hit_streak_ >= kMinHits || frame_index < kMinHits)) {
                                                const auto &bbox = trk.second.GetStateAsBbox();
                                                cv::Rect myRect_to_cv(bbox.block.x,bbox.block.y,bbox.block.width,bbox.block.height);
                                                std::string display_str=std::to_string(frame_index);
                                                display_str+=" ";
                                               // display_str+=std::to_string(trk.second.category);
                                              //  display_str+=" ";
                                                display_str+=std::to_string(trk.first);
                                                cv::putText(img_tracking, display_str, cv::Point(bbox.block.tl().x, bbox.block.tl().y - 10),cv::FONT_HERSHEY_DUPLEX, 1, cv::Scalar(255, 255, 255), 1);
                                                cv::rectangle(img_tracking, myRect_to_cv, colors[trk.first % num_of_colors], 3);
                                                trk.second.drawstateline(img_tracking,colors[trk.first % num_of_colors]);
                                            }

                                        }

                                       // Show our image inside it
                                        cv::namedWindow("Detecing", CV_WINDOW_NORMAL);
                                        cv::namedWindow("Tracking", CV_WINDOW_NORMAL);

                                        p->video_opencv(frame);


                                        cv::imshow("Detecing", frame);
                                        writer_dec<<frame;

                                        cv::imshow("Tracking", img_tracking);
                                        writer_match<<img_tracking;
                                        //p->video_opencv(img_tracking);

                                        // Exit if ESC pressed
                                        int c=cv::waitKey(1);
                                              if((char)c==27)
                                                  break;
                                              else if(c>=0)
                                                 cv:: waitKey(1);
                                    } // end of enable_display_flag



            free(srcImg);
            free(resizeImg);
            frame_index++;

        }//while stop

         //std::cout<<"while end";
        std::vector<std::string> judge_txt;
        judge_txt.push_back("1,2,3,4,5,6,7");

        string aa="请点击右边 显示内容 按钮显示事故诊断结果";
        p->printmsg("视频已处理完成，在视频原目录下生成"+output_path+"  "+folder+name+"match.mp4"+"\n"+aa);


        output_file.close();

        free_network(net);
        //std::cout<<"dec_match"<<output_path;
        return output_path;
}
